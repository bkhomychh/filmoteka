{"version":3,"file":"static/js/472.3ec7c75e.chunk.js","mappings":"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","sources":["webpack://filmoteka/./src/components/Movie/Movie.module.scss?674c","components/Movie/Movie.jsx","../node_modules/@tanstack/query-core/src/queryObserver.ts","../node_modules/@tanstack/react-query/src/useSyncExternalStore.ts","../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx","../node_modules/@tanstack/react-query/src/isRestoring.tsx","../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts","../node_modules/@tanstack/react-query/src/utils.ts","../node_modules/@tanstack/react-query/src/useBaseQuery.ts","../node_modules/@tanstack/react-query/src/suspense.ts","../node_modules/@tanstack/react-query/src/useQuery.ts","../node_modules/src/observe.ts","webpack://filmoteka/./src/components/MovieCarousel/MovieCarousel.module.scss?517c","components/MovieCarousel/MovieCarousel.jsx","pages/Home.jsx","services/moviesAPI.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js","../node_modules/use-sync-external-store/shim/index.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"link\":\"Movie_link__TtNxb\",\"poster\":\"Movie_poster__O4gfr\",\"icon\":\"Movie_icon__zxB3-\",\"title\":\"Movie_title__9f19-\",\"score\":\"Movie_score__ya-UI\"};","import PropTypes from 'prop-types';\nimport { Link } from 'react-router-dom';\n\nimport { getDataFromLocalStorage } from 'services/localStorage';\nimport { IMAGE_BASE_URL } from 'utils/constants';\n\nimport { FaBookmark } from 'react-icons/fa';\nimport { AiFillStar } from 'react-icons/ai';\nimport imagePlaceHolder from 'assets/images/image-place-holder.png';\nimport styles from './Movie.module.scss';\n\nconst Movie = ({ movie, location }) => {\n  const { id, title, poster_path, vote_average } = movie;\n  const imgUrl = poster_path ? IMAGE_BASE_URL + poster_path : imagePlaceHolder;\n\n  const data = getDataFromLocalStorage('movies');\n  const isSaved = data ? data.some(el => el.id === id) : false;\n\n  return (\n    <>\n      <Link\n        className={styles.link}\n        to={`/search/${id}`}\n        state={{ from: location }}\n      >\n        <img\n          className={styles.poster}\n          src={imgUrl}\n          alt={title}\n          loading=\"lazy\"\n        />\n        {isSaved && <FaBookmark className={styles.icon} />}\n      </Link>\n      <h3 className={styles.title}>{title}</h3>\n      <p className={styles.score}>\n        {vote_average.toFixed(1)} <AiFillStar />\n      </p>\n    </>\n  );\n};\n\nMovie.propTypes = {\n  movie: PropTypes.object.isRequired,\n  location: PropTypes.object.isRequired,\n};\n\nexport default Movie;\n","import type { DefaultedQueryObserverOptions, RefetchPageFilters } from './types'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport type {\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\nimport type { Query, QueryState, Action, FetchOptions } from './query'\nimport type { QueryClient } from './queryClient'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch, isCancelledError } from './retryer'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  cache?: boolean\n  listeners?: boolean\n  onError?: boolean\n  onSuccess?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  options: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n\n  private client: QueryClient\n  private currentQuery!: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  private currentQueryInitialState!: QueryState<TQueryData, TError>\n  private currentResult!: QueryObserverResult<TData, TError>\n  private currentResultState?: QueryState<TQueryData, TError>\n  private currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  private previousQueryResult?: QueryObserverResult<TData, TError>\n  private selectError: TError | null\n  private selectFn?: (data: TQueryData) => TData\n  private selectResult?: TData\n  private staleTimeoutId?: ReturnType<typeof setTimeout>\n  private refetchIntervalId?: ReturnType<typeof setInterval>\n  private currentRefetchInterval?: number | false\n  private trackedProps!: Set<keyof QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.client = client\n    this.options = options\n    this.trackedProps = new Set()\n    this.selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.remove = this.remove.bind(this)\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch()\n      }\n\n      this.updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.length) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = []\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n    this.currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.currentQuery\n\n    this.options = this.client.defaultQueryOptions(options)\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      typeof options?.isDataEqual !== 'undefined'\n    ) {\n      this.client\n        .getLogger()\n        .error(\n          `The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option`,\n        )\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.currentRefetchInterval)\n    ) {\n      this.updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.client.getQueryCache().build(this.client, options)\n\n    return this.createResult(query, options)\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.currentQuery\n  }\n\n  remove(): void {\n    this.client.getQueryCache().remove(this.currentQuery)\n  }\n\n  refetch<TPageData>({\n    refetchPage,\n    ...options\n  }: RefetchOptions & RefetchPageFilters<TPageData> = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n      meta: { refetchPage },\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.client.defaultQueryOptions(options)\n\n    const query = this.client\n      .getQueryCache()\n      .build(this.client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.currentResult\n    })\n  }\n\n  private executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  private updateStaleTimeout(): void {\n    this.clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  private computeRefetchInterval() {\n    return typeof this.options.refetchInterval === 'function'\n      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)\n      : this.options.refetchInterval ?? false\n  }\n\n  private updateRefetchInterval(nextInterval: number | false): void {\n    this.clearRefetchInterval()\n\n    this.currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.currentRefetchInterval) ||\n      this.currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.executeFetch()\n      }\n    }, this.currentRefetchInterval)\n  }\n\n  private updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval(this.computeRefetchInterval())\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.currentQuery\n    const prevOptions = this.options\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.currentResultState\n    const prevResultOptions = this.currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.currentQueryInitialState\n    const prevQueryResult = queryChange\n      ? this.currentResult\n      : this.previousQueryResult\n\n    const { state } = query\n    let { dataUpdatedAt, error, errorUpdatedAt, fetchStatus, status } = state\n    let isPreviousData = false\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!dataUpdatedAt) {\n          status = 'loading'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Keep previous data if needed\n    if (\n      options.keepPreviousData &&\n      !state.dataUpdatedAt &&\n      prevQueryResult?.isSuccess &&\n      status !== 'error'\n    ) {\n      data = prevQueryResult.data\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt\n      status = prevQueryResult.status\n      isPreviousData = true\n    }\n    // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.selectFn\n      ) {\n        data = this.selectResult\n      } else {\n        try {\n          this.selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.selectResult = data\n          this.selectError = null\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError)\n          }\n          this.selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'loading'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (options.placeholderData as PlaceholderDataFunction<TQueryData>)()\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.selectError = null\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError)\n            }\n            this.selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(prevResult?.data, placeholderData, options) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError as any\n      data = this.selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isLoading = status === 'loading'\n    const isError = status === 'error'\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.currentQuery, this.options)\n    this.currentResultState = this.currentQuery.state\n    this.currentResultOptions = this.options\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = { cache: true }\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n\n      if (\n        notifyOnChangeProps === 'all' ||\n        (!notifyOnChangeProps && !this.trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(notifyOnChangeProps ?? this.trackedProps)\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  private updateQuery(): void {\n    const query = this.client.getQueryCache().build(this.client, this.options)\n\n    if (query === this.currentQuery) {\n      return\n    }\n\n    const prevQuery = this.currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.currentQuery = query\n    this.currentQueryInitialState = query.state\n    this.previousQueryResult = this.currentResult\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(action: Action<TData, TError>): void {\n    const notifyOptions: NotifyOptions = {}\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true\n    }\n\n    this.updateResult(notifyOptions)\n\n    if (this.hasListeners()) {\n      this.updateTimers()\n    }\n  }\n\n  private notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        this.options.onSuccess?.(this.currentResult.data!)\n        this.options.onSettled?.(this.currentResult.data!, null)\n      } else if (notifyOptions.onError) {\n        this.options.onError?.(this.currentResult.error!)\n        this.options.onSettled?.(undefined, this.currentResult.error!)\n      }\n\n      // Then trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated',\n        })\n      }\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: typeof options['refetchOnMount'] &\n    typeof options['refetchOnWindowFocus'] &\n    typeof options['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","'use client'\nimport * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport { notifyManager } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseBaseQueryOptions } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, shouldSuspend, fetchOptimistic } from './suspense'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\nimport type { QueryFunction, QueryKey } from '@tanstack/query-core'\nimport { parseQueryArgs, QueryObserver } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","import type { ObserverInstanceCallback } from './index';\n\nconst observerMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: WeakMap<Element | Document, string> = new WeakMap();\nlet rootId = 0;\n\nlet unsupportedValue: boolean | undefined = undefined;\n\n/**\n * What should be the default behavior if the IntersectionObserver is unsupported?\n * Ideally the polyfill has been loaded, you can have the following happen:\n * - `undefined`: Throw an error\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\n * **/\nexport function defaultFallbackInView(inView: boolean | undefined) {\n  unsupportedValue = inView;\n}\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root: IntersectionObserverInit['root']) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter((key) => options[key] !== undefined)\n    .map((key) => {\n      return `${key}_${\n        key === 'root' ? getRootId(options.root) : options[key]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = observerMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-ignore support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    observerMap.set(id, instance);\n  }\n\n  return instance;\n}\n\n/**\n * @param element - DOM Element to observe\n * @param callback - Callback function to trigger when intersection status changes\n * @param options - Intersection Observer options\n * @param fallbackInView - Fallback inView value.\n * @return Function - Cleanup function that should be triggered to unregister the observer\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n  fallbackInView = unsupportedValue,\n) {\n  if (\n    typeof window.IntersectionObserver === 'undefined' &&\n    fallbackInView !== undefined\n  ) {\n    const bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio:\n        typeof options.threshold === 'number' ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds,\n    });\n    return () => {\n      // Nothing to cleanup\n    };\n  }\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  let callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n","// extracted by mini-css-extract-plugin\nexport default {\"genre\":\"MovieCarousel_genre__iWB+w\",\"icon\":\"MovieCarousel_icon__5ATRP\",\"card\":\"MovieCarousel_card__1KFGD\",\"wrapper\":\"MovieCarousel_wrapper__i-8Vn\"};","import PropTypes from 'prop-types';\nimport { useLocation } from 'react-router-dom';\nimport { useQuery } from '@tanstack/react-query';\nimport { useTranslation } from 'react-i18next';\n\nimport Movie from 'components/Movie/Movie';\nimport PageLoader from 'components/PageLoader';\n\nimport { getTrendingMovies, getMoviesByGenre } from 'services/moviesAPI';\n\nimport { Navigation } from 'swiper';\nimport { Swiper, SwiperSlide } from 'swiper/react';\nimport 'swiper/scss';\nimport 'swiper/scss/navigation';\nimport 'swiper/scss/controller';\nimport { useInView } from 'react-intersection-observer';\n\nimport styles from './MovieCarousel.module.scss';\nimport { BsFire } from 'react-icons/bs';\n\nconst MovieCarousel = ({ genre: { name, id } }) => {\n  const {\n    t,\n    i18n: { language },\n  } = useTranslation();\n\n  const location = useLocation();\n\n  // observer settings\n  const { ref, inView } = useInView({\n    triggerOnce: true,\n    threshold: 1,\n    rootMargin: '100px',\n    initialInView: false,\n  });\n\n  // fetching data\n  const { data, isLoading } = useQuery({\n    queryKey: [name],\n    queryFn: () => {\n      if (name === TRENDING) {\n        return getTrendingMovies(language);\n      }\n      return getMoviesByGenre(id, language);\n    },\n    enabled: inView,\n  });\n\n  const TRENDING = t('home.additional_genre.trending');\n  const sliderOptions = {\n    slidesPerView: 3,\n    spaceBetween: 20,\n    navigation: true,\n    modules: [Navigation],\n    breakpoints: {\n      768: {\n        slidesPerView: 4,\n      },\n      1200: {\n        slidesPerView: 5,\n      },\n    },\n  };\n\n  if (name === TRENDING) {\n    sliderOptions.slidesPerView = 1;\n    sliderOptions.breakpoints = {\n      768: {\n        slidesPerView: 2,\n        spaceBetween: 30,\n      },\n      1200: {\n        slidesPerView: 3,\n      },\n    };\n  }\n\n  return (\n    <div className={styles.wrapper}>\n      <h2 className={styles.genre} ref={ref}>\n        {name}\n        {name === TRENDING && <BsFire className={styles.icon} />}\n      </h2>\n      {isLoading && <PageLoader />}\n      {data?.length > 0 && (\n        <Swiper {...sliderOptions}>\n          {data.map(movie => (\n            <SwiperSlide className={styles.card} key={movie.id}>\n              <Movie movie={movie} location={location} />\n            </SwiperSlide>\n          ))}\n        </Swiper>\n      )}\n    </div>\n  );\n};\n\nMovieCarousel.propTypes = {\n  genre: PropTypes.object.isRequired,\n};\n\nexport default MovieCarousel;\n","import MovieCarousel from 'components/MovieCarousel';\nimport { getGenreList } from 'services/moviesAPI';\nimport { useTranslation } from 'react-i18next';\nimport { useQuery } from '@tanstack/react-query';\n\nconst Home = () => {\n  const {\n    t,\n    i18n: { language },\n  } = useTranslation();\n\n  const TRENDING = t('home.additional_genre.trending');\n\n  const { data } = useQuery({\n    queryKey: ['genres'],\n    queryFn: () => {\n      return getGenreList(language);\n    },\n\n    refetchInterval: 5 * 60 * 1000,\n    keepPreviousData: true,\n  });\n\n  return (\n    <>\n      <MovieCarousel genre={{ name: TRENDING }} />\n      {data?.length > 0 &&\n        data.map(genre => <MovieCarousel key={genre.id} genre={genre} />)}\n    </>\n  );\n};\n\nexport default Home;\n","import axios from 'axios';\n\nimport { BASE_URL, API_KEY, RESOURCE } from 'utils/constants';\n\naxios.defaults.baseURL = BASE_URL;\naxios.defaults.params = {\n  api_key: API_KEY,\n};\n\nconst getTrendingMovies = (language = 'en') => {\n  const options = {\n    params: { language },\n  };\n  return axios.get(RESOURCE.trending, options).then(res => res.data.results);\n};\n\nconst getGenreList = (language = 'en') => {\n  const options = {\n    params: { language },\n  };\n  return axios.get(RESOURCE.genres, options).then(res => res.data.genres);\n};\n\nconst getMoviesBySearchQuery = (query, language = 'en') => {\n  const options = {\n    params: { query, language },\n  };\n  return axios.get(RESOURCE.search, options).then(res => res.data.results);\n};\n\nconst getMoviesByGenre = (genreId, language = 'en') => {\n  const options = {\n    params: {\n      with_genres: genreId,\n      sort_by: 'popularity.desc',\n      'vote_average.gte': 5,\n      'primary_release_date.gte': '2010-01-01',\n      language,\n    },\n  };\n\n  return axios.get(RESOURCE.discover, options).then(res => res.data.results);\n};\n\nconst getMovieDetails = (id, language = 'en') => {\n  const options = {\n    params: { language },\n  };\n\n  return axios.get(RESOURCE.movieDetails(id), options).then(res => res.data);\n};\n\nconst getMovieCredits = (id, language = 'en') => {\n  const options = {\n    params: { language },\n  };\n  return axios\n    .get(RESOURCE.movieCredits(id), options)\n    .then(res => res.data.cast);\n};\n\nconst getMovieReviews = (id, language = 'en') => {\n  const options = {\n    params: { language },\n  };\n  return axios\n    .get(RESOURCE.movieReviews(id), options)\n    .then(res => res.data.results);\n};\n\nconst getVideos = (id, language = 'en') => {\n  const options = {\n    params: { language },\n  };\n  return axios.get(RESOURCE.videos(id), options).then(res => res.data.results);\n};\n\nexport {\n  getTrendingMovies,\n  getGenreList,\n  getMoviesBySearchQuery,\n  getMoviesByGenre,\n  getMovieDetails,\n  getMovieCredits,\n  getMovieReviews,\n  getVideos,\n};\n","/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var e=require(\"react\");function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c})},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c})})},[a]);p(d);return d}\nfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n"],"names":["movie","location","id","title","poster_path","vote_average","imgUrl","IMAGE_BASE_URL","imagePlaceHolder","data","getDataFromLocalStorage","isSaved","some","el","className","styles","to","state","from","src","alt","loading","toFixed","refetch","onSubscribe","listeners","length","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","onUnsubscribe","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","process","env","NODE_ENV","isDataEqual","getLogger","error","QueryObserver","enabled","Error","queryKey","updateQuery","mounted","hasListeners","shouldFetchOptionally","updateResult","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","this","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","build","createResult","getCurrentResult","currentResult","trackResult","result","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","refetchPage","fetch","meta","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","cancelRefetch","_fetchOptions$cancelR","promise","throwOnError","catch","constructor","client","noop","options","isValidTimeout","trackedProps","isStale","time","timeUntilStale","dataUpdatedAt","timeout","staleTimeoutId","setTimeout","refetchInterval","_this$options$refetch","bindMethods","refetchIntervalId","setInterval","refetchIntervalInBackground","focusManager","isFocused","clearTimeout","undefined","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","observer","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","errorUpdatedAt","fetchStatus","status","remove","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","canFetch","Set","shallowEqualObjects","networkMode","keepPreviousData","isSuccess","select","selectFn","selectResult","replaceData","placeholderData","Date","now","isFetching","isLoading","isError","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","cache","notifyOnChangeProps","isRefetching","size","includedProps","useErrorBoundary","bind","selectError","changed","has","onQueryUpdate","action","onSuccess","manual","isCancelledError","onError","notifyManager","batch","onSettled","setOptions","Subscribable","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","value","isReset","reset","children","clearReset","IsRestoringContext","IsRestoringProvider","_useErrorBoundary","params","suspense","useClearResetErrorBoundary","ensurePreventErrorBoundaryRetry","useSyncExternalStore","isRestoring","willFetch","errorResetBoundary","Map","RootIds","WeakMap","rootId","unsupportedValue","defaultFallbackInView","inView","getRootId","root","set","sort","filter","map","createObserver","instance","threshold","intersectionRatio","trackVisibility","isVisible","IntersectionObserver","entries","entry","isIntersecting","target","callback","Array","element","isArray","fallbackInView","window","bounds","getBoundingClientRect","boundingClientRect","thresholds","intersectionRect","rootBounds","callbacks","push","observe","unobserve","splice","indexOf","delete","disconnect","isPlainChildren","props","InView","node","_unobserveCb","handleNode","triggerOnce","setState","initialInView","skip","observeNode","handleChange","onChange","componentDidUpdate","prevProps","observerMap","genre","name","useTranslation","t","language","i18n","useLocation","useEffect","current","ref","as","createElement","useState","entryTarget","setRef","React","useInView","rootMargin","useQuery","queryFn","TRENDING","getTrendingMovies","getMoviesByGenre","sliderOptions","slidesPerView","spaceBetween","navigation","modules","Navigation","breakpoints","PageLoader","Movie","getGenreList","axios","BASE_URL","api_key","API_KEY","RESOURCE","res","results","genres","getMoviesBySearchQuery","query","genreId","with_genres","sort_by","getMovieDetails","getMovieCredits","cast","getMovieReviews","getVideos","e","require","k","is","a","b","l","m","n","useLayoutEffect","p","useDebugValue","r","getSnapshot","d","f","u","document","inst","c","g","exports","module"],"sourceRoot":""}